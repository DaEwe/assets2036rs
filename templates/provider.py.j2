{% extends "base.py.j2" %}

{% block methods %}
    {# --- Provider Properties --- #}
    {% for prop in properties %}
    @property
    def {{ prop.name_snake }}(self) -> Optional[{{ prop.python_type }}]:
        if hasattr(self, '_prop_{{ prop.name_snake }}'):
            return self._prop_{{ prop.name_snake }}.value  # type: ignore
        # print(f"Warning: Accessing '{{ prop.name_snake }}' but underlying '_prop_{{ prop.name_snake }}' not found.") # Optional debug
        return None

    @{{ prop.name_snake }}.setter
    def {{ prop.name_snake }}(self, value: {{ prop.python_type }}) -> None:
        if hasattr(self, '_prop_{{ prop.name_snake }}'):
            self._prop_{{ prop.name_snake }}.value = value  # type: ignore[assignment]
        else:
            raise AttributeError(f"Property '{{ prop.name_snake }}' not initialized or does not support setting.")

    def on_{{ prop.name_snake }}_change(self, callback: Callable[[Optional[{{ prop.python_type }}]], None]) -> None:
        if hasattr(self, '_prop_{{ prop.name_snake }}'):
            self._prop_{{ prop.name_snake }}.on_change(callback)  # type: ignore
        else:
            print(f"Warning: Property '{{ prop.name_snake }}' not fully initialized for on_change subscription.")
    {% endfor %}

    {# --- Provider Operations --- #}
    {% for op in operations %}
    def bind_{{ op.name_snake }}(self, callback: Callable[[{% for param in op.params %}{{ param.type_py }}{% if not loop.last %}, {% endif %}{% endfor %}], {{ op.return_type }}]) -> None:
        # internal_callback_wrapper adapts the user's typed callback to the
        # (parameters: Dict[str, Any]) -> Any signature expected by assets.py BindableOperation.bind.
        def internal_callback_wrapper(parameters: Dict[str, Any]) -> Any:
            try:
                # Prepare arguments for the user's callback, ensuring correct names.
                # assets.py's BindableOperation already validates parameters against its schema.
                cb_args = {
                    {%- for param in op.params %}
                    "{{ param.name_snake }}": parameters.get("{{ param.name_snake }}")
                    {%- if not loop.last %},{% endif %}
                    {%- endfor %}
                }
                # Filter out None values if a param was not in `parameters`
                # This handles cases where a parameter might be optional in the submodel definition
                # but the Python type hint doesn't explicitly show Optional (e.g. for int, str defaults).
                # The user's callback should handle Optional types if a parameter truly can be absent.
                cb_args_filtered = {k: v for k, v in cb_args.items() if k in parameters}

                return callback(**cb_args_filtered) # Call the user-provided callback
            except Exception as e:
                print(f"Error in user-provided callback for operation '{{ op.name }}': {e}")
                {% if op.return_type != "None" %}
                return {{ op.return_default_value }}
                {% else %}
                return None
                {% endif %}

        if hasattr(self, '_op_{{ op.name_snake }}'): # Corrected attribute name
            self._op_{{ op.name_snake }}.bind(internal_callback_wrapper)
        else:
            raise AttributeError(f"Operation '{{ op.name_snake }}' not initialized.")
    {% endfor %}
    {# --- Provider Event Triggers --- #}
    {% for event in events %}
    def trigger_{{ event.name_snake }}(self{% for param in event.payload_params %}, {{ param.name_snake }}: {{ param.type_py }}{% endfor %}) -> None: # Changed event.trigger_params to event.payload_params
        if hasattr(self, '_event_{{ event.name_snake }}'):
            # Construct the parameters dictionary expected by TriggerableEvent.trigger()
            params_dict = {
                {%- for param in event.payload_params %}
                "{{ param.name_snake }}": {{ param.name_snake }}{% if not loop.last %},{% endif %}
                {%- endfor %}
            }
            # print(f"DEBUG_PROVIDER: Triggering event '{{ event.name }}' with params_dict: {params_dict}") # Optional Debug
            self._event_{{ event.name_snake }}.trigger(**params_dict)
        else:
            # This would indicate an initialization error in __init__
            raise AttributeError(f"Event '{{ event.name_snake }}' not initialized properly.")
    {% endfor %}
{% endblock methods %}
